/*
                           /!\ HUMANS BEWARE /!\
=================================================================================
||                                                                             ||
|| THIS FILE IS GENERATED BY MACHINES AND ANY EDITING BY HUMANS IS PROHIBITED! ||
||                                                                             ||
=================================================================================
 */

package lepus.client.codecs

import lepus.protocol.*
import lepus.protocol.domains.*
import lepus.protocol.classes.*
import lepus.protocol.classes.QueueClass.*
import lepus.protocol.constants.*
import lepus.client.codecs.DomainCodecs.*
import scodec.{Codec, Encoder, Decoder}
import scodec.codecs.*

object QueueCodecs {

  private val declareCodec: Codec[Declare] =
    ((short16.unit(0) :: queueName) ++ (byteAligned(
      bool :: bool :: bool :: bool :: noWait
    ) :+ (fieldTable)))
      .as[Declare]
      .withContext("declare method")

  private val declareOkCodec: Codec[DeclareOk] =
    (queueName :: messageCount :: int32)
      .as[DeclareOk]
      .withContext("declareOk method")

  private val bindCodec: Codec[Bind] =
    ((short16.unit(
      0
    ) :: queueName :: exchangeName :: shortString) ++ (byteAligned(
      noWait
    ) :: (fieldTable)))
      .as[Bind]
      .withContext("bind method")

  private val bindOkCodec: Codec[BindOk.type] =
    provide(BindOk)
      .withContext("bindOk method")

  private val unbindCodec: Codec[Unbind] =
    (short16.unit(0) :: queueName :: exchangeName :: shortString :: fieldTable)
      .as[Unbind]
      .withContext("unbind method")

  private val unbindOkCodec: Codec[UnbindOk.type] =
    provide(UnbindOk)
      .withContext("unbindOk method")

  private val purgeCodec: Codec[Purge] =
    (short16.unit(0) :: queueName :: (byteAligned(noWait)))
      .as[Purge]
      .withContext("purge method")

  private val purgeOkCodec: Codec[PurgeOk] =
    (messageCount)
      .as[PurgeOk]
      .withContext("purgeOk method")

  private val deleteCodec: Codec[Delete] =
    ((short16.unit(0) :: queueName) ++ (byteAligned(bool :: bool :: noWait)))
      .as[Delete]
      .withContext("delete method")

  private val deleteOkCodec: Codec[DeleteOk] =
    (messageCount)
      .as[DeleteOk]
      .withContext("deleteOk method")

  val all: Codec[QueueClass] =
    discriminated[QueueClass]
      .by(methodId)
      .typecase(MethodId(10), declareCodec)
      .typecase(MethodId(11), declareOkCodec)
      .typecase(MethodId(20), bindCodec)
      .typecase(MethodId(21), bindOkCodec)
      .typecase(MethodId(50), unbindCodec)
      .typecase(MethodId(51), unbindOkCodec)
      .typecase(MethodId(30), purgeCodec)
      .typecase(MethodId(31), purgeOkCodec)
      .typecase(MethodId(40), deleteCodec)
      .typecase(MethodId(41), deleteOkCodec)
      .withContext("queue methods")

}

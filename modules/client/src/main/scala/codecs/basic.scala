/*
                           /!\ HUMANS BEWARE /!\
=================================================================================
||                                                                             ||
|| THIS FILE IS GENERATED BY MACHINES AND ANY EDITING BY HUMANS IS PROHIBITED! ||
||                                                                             ||
=================================================================================
 */

package lepus.client.codecs

import lepus.protocol.*
import lepus.protocol.domains.*
import lepus.protocol.classes.*
import lepus.protocol.classes.BasicClass.*
import lepus.protocol.constants.*
import lepus.client.codecs.DomainCodecs.*
import scodec.{Codec, Encoder, Decoder}
import scodec.codecs.*

object BasicCodecs {

  private val qosCodec: Codec[Qos] =
    (int32 :: short16 :: bool)
      .as[Qos]
      .withContext("qos method")

  private val qosOkCodec: Codec[QosOk.type] =
    provide(QosOk)
      .withContext("qosOk method")

  private val consumeCodec: Codec[Consume] =
    (short16.unit(
      0
    ) :: queueName :: consumerTag :: noLocal :: noAck :: bool :: noWait :: fieldTable)
      .as[Consume]
      .withContext("consume method")

  private val consumeOkCodec: Codec[ConsumeOk] =
    (consumerTag)
      .as[ConsumeOk]
      .withContext("consumeOk method")

  private val cancelCodec: Codec[Cancel] =
    (consumerTag :: noWait)
      .as[Cancel]
      .withContext("cancel method")

  private val cancelOkCodec: Codec[CancelOk] =
    (consumerTag)
      .as[CancelOk]
      .withContext("cancelOk method")

  private val publishCodec: Codec[Publish] =
    (short16.unit(0) :: exchangeName :: shortString :: bool :: bool)
      .as[Publish]
      .withContext("publish method")

  private val returnCodec: Codec[Return] =
    (replyCode :: replyText :: exchangeName :: shortString)
      .as[Return]
      .withContext("return method")

  private val deliverCodec: Codec[Deliver] =
    (consumerTag :: deliveryTag :: redelivered :: exchangeName :: shortString)
      .as[Deliver]
      .withContext("deliver method")

  private val getCodec: Codec[Get] =
    (short16.unit(0) :: queueName :: noAck)
      .as[Get]
      .withContext("get method")

  private val getOkCodec: Codec[GetOk] =
    (deliveryTag :: redelivered :: exchangeName :: shortString :: messageCount)
      .as[GetOk]
      .withContext("getOk method")

  private val getEmptyCodec: Codec[GetEmpty.type] =
    (emptyShortString) ~> provide(GetEmpty)
      .withContext("getEmpty method")

  private val ackCodec: Codec[Ack] =
    (deliveryTag :: bool)
      .as[Ack]
      .withContext("ack method")

  private val rejectCodec: Codec[Reject] =
    (deliveryTag :: bool)
      .as[Reject]
      .withContext("reject method")

  private val recoverAsyncCodec: Codec[RecoverAsync] =
    (bool)
      .as[RecoverAsync]
      .withContext("recoverAsync method")

  private val recoverCodec: Codec[Recover] =
    (bool)
      .as[Recover]
      .withContext("recover method")

  private val recoverOkCodec: Codec[RecoverOk.type] =
    provide(RecoverOk)
      .withContext("recoverOk method")

  private val nackCodec: Codec[Nack] =
    (deliveryTag :: bool :: bool)
      .as[Nack]
      .withContext("nack method")

  val all: Codec[BasicClass] =
    discriminated[BasicClass]
      .by(methodId)
      .typecase(MethodId(10), qosCodec)
      .typecase(MethodId(11), qosOkCodec)
      .typecase(MethodId(20), consumeCodec)
      .typecase(MethodId(21), consumeOkCodec)
      .typecase(MethodId(30), cancelCodec)
      .typecase(MethodId(31), cancelOkCodec)
      .typecase(MethodId(40), publishCodec)
      .typecase(MethodId(50), returnCodec)
      .typecase(MethodId(60), deliverCodec)
      .typecase(MethodId(70), getCodec)
      .typecase(MethodId(71), getOkCodec)
      .typecase(MethodId(72), getEmptyCodec)
      .typecase(MethodId(80), ackCodec)
      .typecase(MethodId(90), rejectCodec)
      .typecase(MethodId(100), recoverAsyncCodec)
      .typecase(MethodId(110), recoverCodec)
      .typecase(MethodId(111), recoverOkCodec)
      .typecase(MethodId(120), nackCodec)
      .withContext("basic methods")

}
